<section class="card" id="explanationDetailed">
  <h2>Explanation & Background (detailed)</h2>

  <p><strong>RSA — overview and math.</strong> RSA is an asymmetric cryptosystem based on number theory. It uses a key pair: a <em>public key</em> for encryption and a <em>private key</em> for decryption. Keys are built from two (large) prime numbers <code>p</code> and <code>q</code>:</p>
  <ol>
    <li>Compute <code>n = p × q</code>. The modulus <code>n</code> is part of both the public and private keys.</li>
    <li>Compute Euler's totient (for demonstration): <code>φ(n) = (p−1) × (q−1)</code>.</li>
    <li>Choose a public exponent <code>e</code> such that <code>gcd(e, φ(n)) = 1</code> (common choices: 65537, 17, 3).</li>
    <li>Compute the private exponent <code>d</code> as the modular inverse of <code>e</code> modulo <code>φ(n)</code>, i.e. <code>d ≡ e⁻¹ (mod φ(n))</code>.</li>
    <li>Public key is <code>(e, n)</code>; private key is <code>(d, n)</code>.</li>
  </ol>

  <p><strong>Encryption / decryption (numerical):</strong> to encrypt an integer message <code>m</code> (0 ≤ m &lt; n) compute <code>c = m^e mod n</code>. To decrypt compute <code>m = c^d mod n</code>. In practice RSA operates on numeric blocks (combined bytes) and uses padding (e.g., OAEP) before exponentiation for security.</p>

  <h3>From text to numbers</h3>
  <p>Because RSA works on numbers, we convert characters to numeric blocks. In this demo we use a per-character encoding (each character → its Unicode/ASCII code). This makes the demo simple and educational but also makes it vulnerable: encrypting each character individually leaks patterns and frequencies that can be exploited.</p>

  <h3>Security fundamentals — why real RSA is secure</h3>
  <ul>
    <li><strong>Factorization hardness:</strong> The security of RSA rests on the practical difficulty of factoring a large modulus <code>n</code> into <code>p</code> and <code>q</code>. With large (2048-bit) primes, factoring is infeasible with current technology.</li>
    <li><strong>Padding:</strong> Proper padding (OAEP, PKCS#1) before encryption removes deterministic mapping between plaintexts and ciphertexts and defends against many attacks (textbook RSA = insecure).</li>
    <li><strong>Block size:</strong> Real implementations encrypt blocks (large numeric messages) after padding; per-character encryption is insecure for demonstration purposes only.</li>
  </ul>

  <h3>Reference-distribution attack — concept and why it works here</h3>
  <p><strong>Intuition:</strong> If encryption is done per character and the modulus is small, the same plaintext character will often map to the same ciphertext value (deterministic mapping). Frequencies of characters (for example, 'E' is common in English) can survive encryption as frequency patterns in ciphertext. A statistical attacker can exploit that by mapping frequent ciphertext values back to likely plaintext characters using a reference letter distribution.</p>

  <p><strong>Step-by-step attack used in this homework (per-block candidate selection):</strong></p>
  <ol>
    <li>Take the ciphertext block <code>c</code> (a number). For each printable candidate plaintext value <code>m</code> (e.g., ASCII 32–126), compute <code>m^e mod n</code> and check whether it equals <code>c</code>. If it equals, add <code>m</code> to the candidate list for that block.</li>
    <li>If a block yields a single candidate, that candidate is the recovered character. If there are multiple candidates, use a language reference distribution (e.g., English letter frequencies) to pick the most plausible candidate (highest prior probability).</li>
    <li>Repeat for every ciphertext block to reconstruct a plaintext string made of the best-guess characters.</li>
  </ol>

  <h3>Limitations and reliability</h3>
  <p>This statistical approach works well for small modulus and per-character encryption, especially with short plaintext and English text. It is not a general RSA break for properly implemented RSA with padding and large modulus. The method is heuristic and may produce errors (unknown characters or incorrect guesses) when multiple candidates have similar probabilities.</p>

  <h3>Mitigations (what correct systems do)</h3>
  <ul>
    <li>Use large keys (2048+ bits) so factoring is infeasible.</li>
    <li>Use randomized padding (OAEP) before RSA so ciphertexts are non-deterministic and leak no direct frequency information.</li>
    <li>Encrypt larger blocks (not single characters) and use authenticated encryption where appropriate.</li>
  </ul>

  <h3>What this demo shows</h3>
  <p>By using small primes and per-character encryption we purposely create a weak setup so the reference distribution attack succeeds for demonstration. The goal is educational: show how naive uses of cryptography leak statistical structure that attackers exploit.</p>
</section>

    <footer>
      <div class="small">&copy; 2025 Javid Farzaliyev — La Sapienza University</div>
    </footer>
  </div>


